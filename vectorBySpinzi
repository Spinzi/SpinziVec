/*
* ALPHA, BUGS MAY OCCUR
 * Vectors by Spinzi â€” Custom Dynamic Integer Array Class
 * -------------------------------------------------
 * Author: Spinzi
 *
 * Description:
 * This class provides a simplified dynamic array for integers,
 * supporting operations such as reading from input, appending elements,
 * exporting subarrays, and copying data. Memory management is encapsulated
 * within a dedicated struct (sArray) to improve safety and maintainability.
 *
 * I choosed to create this class in order to improve my coding abilities and
 * to better understand memory management inside C++.
 *
 * Key Features:
 * - Manual dynamic memory management with RAII principles
 * - Copy constructor and copy assignment disabled to prevent shallow copies
 * - Flexible build and import functions (partially implemented)
 * - Designed as a learning tool and foundation for more complex data structures
 *
 * Notes:
 * - Length is explicitly tracked; arrays are not zero-terminated.
 * - This implementation is a base for further extension, such as move semantics,
 *   bounds checking, and exception safety.
 */


 // to do: add a logger and progress bar


#include <iostream>
#include <fstream>
#include <ctime>
#include <iomanip>

#pragma warning(disable : 4996)



struct sArray {
	int* data = nullptr;
	int length = 0;
	char* vName = nullptr;

	sArray(char* name = nullptr) {
		if (name) {
			size_t len = strlen(name) + 1; // +1 for null terminator
			vName = new char[len];
			strcpy(vName, name);
		}
		else {
			const char* defaultName = "Unnamed";
			size_t len = strlen(defaultName) + 1;
			vName = new char[len];
			strcpy(vName, defaultName);
		}
	};


	void rename(char* name = nullptr) {
		delete[] vName;
		if (name) {
			size_t len = strlen(name) + 1; // +1 for null terminator
			vName = new char[len];
			strcpy(vName, name);
		}
		else {
			const char* defaultName = "Unnamed";
			size_t len = strlen(defaultName) + 1;
			vName = new char[len];
			strcpy(vName, defaultName);
		}
	}

	void rebuild(int size) {
		length = size;
		delete[] data;
		data = new int[length];
	}

	sArray(int size) : length(size) {
		if (size > 0)
			data = new int[length];
	};

	~sArray() {
		delete[] data;
		delete[] vName;
	}

	sArray(const sArray&) = delete;//still need to understand this part
	sArray& operator=(const sArray& other) = delete;//also this one I need to understand
};

class vectorBySpinzi {
public:
	sArray vectorEl;

	void read() {
		int vector_length;
		std::cin >> vector_length;
		vectorEl.rebuild(vector_length);
		for (int i = 0; i < vectorEl.length; i++) {
			std::cin >> vectorEl.data[i];
		}
		sLog("Read vector.");
	}

	void print() {
		for (int i = 0; i < vectorEl.length; i++) {
			std::cout << vectorEl.data[i] << ' ';
		}
		sLog("Printed vector");
	}

	void rename(const char* name) {
		unsigned int ln = strlen(name) + 1;
		char* nm = new char[ln];
		strcpy(nm, name);
		vectorEl.rename(nm);
		delete[] nm;
	}

	void copy(const sArray& from, sArray& to) {
		if (to.length < from.length) {
			to.rebuild(from.length);
		}
		for (int i = 0; i < from.length; i++) {
			to.data[i] = from.data[i];
		}
		sLog("Copied elements of two arrays.", from.vName, to.vName);
	}

	void append(int val) {
		sArray t;
		copy(vectorEl, t);
		vectorEl.rebuild(vectorEl.length + 1);
		copy(t, vectorEl);
		vectorEl.data[vectorEl.length - 1] = val;
		//sLog("Appended element to vector. Appended element: ", );
	}

	void pop_at(int pos = -1, int sz = 1) {
		if (pos > vectorEl.length - 1 || pos < 0)
			pos = vectorEl.length - 1;
		if (pos + sz > vectorEl.length)
		{
			throw std::out_of_range("pop range out of bounds");
			return;
		}
		for (int i = pos; i < vectorEl.length - sz; i++) {
			vectorEl.data[i] = vectorEl.data[i + sz];
		}
		vectorEl.length = vectorEl.length - sz;
		sArray t;
		copy(vectorEl, t);
		vectorEl.rebuild(vectorEl.length);
		copy(t, vectorEl);
	}

	void sLog(const char* msg, const char* optOne = "", const char* optTwo = "") {
		if (!logging)
			return;

		std::ofstream log("log.txt", std::ios::app);
		std::time_t timestamp = time(0);
		tm* now = std::localtime(&timestamp);

		log << '[' << std::put_time(now, "%Y-%m-%d %H:%M:%S") << ']'
			<< " Element: " << (vectorEl.vName ? vectorEl.vName : "Unnamed")
			<< "; " << msg << ' ' << (optOne ? optOne : "") << ' ' << (optTwo ? optTwo : "") << '\n';
	}

	char* to_charS(int val) {
		bool negative = false;
		if (val < 0) negative = true;
		int vLength = numbLength(val);
		char* str = new char[vLength+1];
		str[vLength + 1] = '/0';
		for (int i = vLength-1; i >= 0 ; i--) {
			str[i] = numbToChar(val % 10);
			val /= 10;
		}
		return str;

		bool negatie = 0;
		int starting_position = 0;

	}

	int numbLength(int n) {
		if (n == 0) return 1;
		int l = 0;
		while (n)
		{
			n / 10;
			l++;
		}
		return l;
	}

	char numbToChar(int val) {
		return val + 48;
	}

	void logOn() {
		logging = true;
	}

	void logOff() {
		logging = false;
	}

private:
	bool logging = false;

};

//this is just for texting purposes, will be removed in fila product
int main() {
	vectorBySpinzi el;
	el.logOn();
	el.rename("Ghita");
	el.read();
	el.append(41);
	el.pop_at(1, 1);
	el.print();
}
